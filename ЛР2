# Вариант 3. Пересечение множеств
def task1():
    print("Решение задачи 1")
def find_common_elements(list1, list2):
    return sorted(set(list1) & set(list2))

# Вводим множества
list1 = [1, 3, 2]
list2 = [4, 3, 2]

result1 = find_common_elements(list1, list2)



# Вариант 13. Родословная: LCA
def task2():
    print("Решение задачи 2")
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

def lowest_common_ancestor(root, p, q):
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root
    return left if left else right

# Создаем генеалогическое древо
root = TreeNode("Фрукты")
root.left = TreeNode("Цитрусы")
root.right = TreeNode("Ягода")
root.left.left = TreeNode("Апельсин")
root.left.right = TreeNode("Лимон")
root.right.left = TreeNode("Клубника")
root.right.right = TreeNode("Арбуз")
root.left.right.left = TreeNode("Спелый лимон")
root.left.right.right = TreeNode("Зеленый лимон")
root.right.right.left = TreeNode("Красный арбуз")
root.right.right.right = TreeNode("Желтый арбуз")

#Выбираем элементы для которых необходимо найти общего предка
p = root.right.right
q = root.right.right.right

result2 = lowest_common_ancestor(root, p, q)



choice = int(input("Введите номер задачи: "))
if choice == 1:
    print(result1)
elif choice == 2:
    print("Наименьший общий предок для {} и {}: {}".format(p.val, q.val, result2.val))
else:
    print("Такой задачи нет")
